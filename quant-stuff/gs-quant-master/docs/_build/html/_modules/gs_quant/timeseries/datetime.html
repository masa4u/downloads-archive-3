

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gs_quant.timeseries.datetime &mdash; gs_quant 0.1 documentation</title>
  

    
  <script crossorigin src="/resources/react/16-8-6/prod/react.production.min.js"></script>
  <script
    crossorigin src="/resources/react/16-8-6/prod/react-dom.production.min.js"></script>

     
    <script src='/resources/mathjax/latest.js?config=TeX-AMS-MML_HTMLorMML' async></script> 
    
    <script type="text/javascript" src="../../../_static/../../../auto-mount.js"></script>
    <link rel="stylesheet" href="../../../_static/../../../auto-mount.css" type="text/css" />

  
  
  
  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" /> 
</head>

<!-- Hello from the future. -->
<div id="mq-doc-navbar-inject"></div>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    <a data-toggle="wy-nav-top" id="gs-developer-action-button-container" ontouchstart="">
      <div data-toggle="gs-nav-action" id="gs-nav-action"></div>
    </a>
    
    <nav id="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        
        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Packages</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Data Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datetime.html">Datetime Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../instrument.html">Instrument Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../markets.html">Markets Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../risk.html">Risk Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../timeseries.html">Timeseries Package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Packages</a> /</li>
        
          <li><a href="../../index.html">Module code</a> /</li>
        
      <li>gs_quant.timeseries.datetime</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gs_quant.timeseries.datetime</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 Goldman Sachs.</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># Unless required by applicable law or agreed to in writing,</span>
<span class="c1"># software distributed under the License is distributed on an</span>
<span class="c1"># &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span>
<span class="c1"># KIND, either express or implied.  See the License for the</span>
<span class="c1"># specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Chart Service will attempt to make public functions (not prefixed with _) from this module available. Such functions</span>
<span class="c1"># should be fully documented: docstrings should describe parameters and the return value, and provide a 1-line</span>
<span class="c1"># description. Type annotations should be provided for parameters.</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Real</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.helper</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..errors</span> <span class="kn">import</span> <span class="n">MqValueError</span>
<span class="kn">from</span> <span class="nn">..datetime.date</span> <span class="kn">import</span> <span class="n">DayCountConvention</span><span class="p">,</span> <span class="n">PaymentFrequency</span><span class="p">,</span> <span class="n">day_count_fraction</span>
<span class="kn">from</span> <span class="nn">..datetime.date</span> <span class="kn">import</span> <span class="n">date_range</span> <span class="k">as</span> <span class="n">_date_range</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Date and time manipulation for timeseries, including date or time shifting, calendar operations, curve alignment and</span>
<span class="sd">interpolation operations. Includes sampling operations based on daif dates[0]te or time manipulation</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">__interpolate_step</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">dates</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s1">&#39;Cannot perform step interpolation on an empty series&#39;</span><span class="p">)</span>

    <span class="n">first_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">dates</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="k">else</span> <span class="n">dates</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># locate previous valid date or take first value from series</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">first_date</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">first_date</span><span class="p">,</span> <span class="s1">&#39;pad&#39;</span><span class="p">)]</span>

    <span class="n">current</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span>

    <span class="n">curve</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>                  <span class="c1"># only need values from dates</span>

    <span class="k">for</span> <span class="n">knot</span> <span class="ow">in</span> <span class="n">curve</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">knot</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">curve</span><span class="p">[</span><span class="n">knot</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">current</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">knot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">curve</span>


<div class="viewcode-block" id="align"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.align.html#gs_quant.timeseries.datetime.align">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">method</span><span class="p">:</span> <span class="n">Interpolate</span> <span class="o">=</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">INTERSECT</span><span class="p">)</span> <span class="o">-&gt;</span> \
        <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Real</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Align dates of two series or scalars</span>

<span class="sd">    :param x: first timeseries or scalar</span>
<span class="sd">    :param y: second timeseries or scalar</span>
<span class="sd">    :param method: interpolation method (default: intersect). Only used when both x and y are timeseries</span>
<span class="sd">    :return: timeseries with specified dates or two scalars from the input</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Align the dates of two series using the specified interpolation method. Returns two series with dates based on the</span>
<span class="sd">    method of interpolation, for example, can be used to intersect the dates of two series, union dates with a defined</span>
<span class="sd">    manner to compute missing values.</span>

<span class="sd">    Interpolation methods:</span>

<span class="sd">    =========   ========================================================================</span>
<span class="sd">    Type        Behavior</span>
<span class="sd">    =========   ========================================================================</span>
<span class="sd">    intersect   Resultant series only have values on the intersection of dates /times.</span>
<span class="sd">    nan         Resultant series have values on the union of dates /times. Values will</span>
<span class="sd">                be NaN for dates or times only present in the other series</span>
<span class="sd">    zero        Resultant series have values on the union of  dates / times. Values will</span>
<span class="sd">                be zero for dates or times only present in the other series</span>
<span class="sd">    step        Resultant series have values on the union of  dates / times. Each series</span>
<span class="sd">                will use the value of the previous valid point if requested date does</span>
<span class="sd">                not exist. Values prior to the first date will be equivalent to the</span>
<span class="sd">                first available value</span>
<span class="sd">    time        Resultant series have values on the union of dates / times. Missing</span>
<span class="sd">                values surrounded by valid values will be interpolated given length of</span>
<span class="sd">                interval. Input series must use DateTimeIndex.</span>
<span class="sd">    =========   ========================================================================</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Stepwize interpolation of series based on dates in second series:</span>

<span class="sd">    &gt;&gt;&gt; a = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; b = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; align(a, b)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`sub`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">y</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">INTERSECT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;inner&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">NAN</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">ZERO</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">TIME</span><span class="p">:</span>
        <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">)</span>
        <span class="n">new_x</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">limit_area</span><span class="o">=</span><span class="s1">&#39;inside&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_y</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">limit_area</span><span class="o">=</span><span class="s1">&#39;inside&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">STEP</span><span class="p">:</span>
        <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">)</span>
        <span class="n">new_x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_y</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfill&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_y</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfill&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s1">&#39;Unknown intersection type: &#39;</span> <span class="o">+</span> <span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="interpolate"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.interpolate.html#gs_quant.timeseries.datetime.interpolate">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">dates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">date</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">time</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">method</span><span class="p">:</span> <span class="n">Interpolate</span> <span class="o">=</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">INTERSECT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate over specified dates or times</span>

<span class="sd">    :param x: timeseries to interpolate</span>
<span class="sd">    :param dates: array of dates/times or another series to interpolate</span>
<span class="sd">    :param method: interpolation method (default: intersect)</span>
<span class="sd">    :return: timeseries with specified dates</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Interpolate the series X over the dates specified by the dates parameter. This can be an array of dates or another</span>
<span class="sd">    series, in which case the index of the series will be used to specify dates</span>

<span class="sd">    Interpolation methods:</span>

<span class="sd">    =========   ========================================================================</span>
<span class="sd">    Type        Behavior</span>
<span class="sd">    =========   ========================================================================</span>
<span class="sd">    intersect   Resultant series only has values on the intersection of dates /times.</span>
<span class="sd">                Will only contain intersection of valid dates / times in the series</span>
<span class="sd">    nan         Resultant series only has values on the intersection of dates /times.</span>
<span class="sd">                Value will be NaN for dates not present in the series</span>
<span class="sd">    zero        Resultant series has values on all requested dates / times. The series</span>
<span class="sd">                will have a value of zero where the requested date or time was not</span>
<span class="sd">                present in the series</span>
<span class="sd">    step        Resultant series has values on all requested dates / times. The series</span>
<span class="sd">                will use the value of the previous valid point if requested date does</span>
<span class="sd">                not exist. Values prior to the first date will be equivalent to the</span>
<span class="sd">                first available value</span>
<span class="sd">    =========   ========================================================================</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Stepwize interpolation of series based on dates in second series:</span>

<span class="sd">    &gt;&gt;&gt; a = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; b = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; interpolate(a, b, Interpolate.INTERSECT)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`sub`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">align_series</span> <span class="o">=</span> <span class="n">dates</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">align_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dates</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">INTERSECT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">align_series</span><span class="p">,</span> <span class="s1">&#39;inner&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">NAN</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">align_series</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">ZERO</span><span class="p">:</span>
        <span class="n">align_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dates</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">align_series</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">STEP</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">__interpolate_step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">align_series</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s1">&#39;Unknown intersection type: &#39;</span> <span class="o">+</span> <span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="value"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.value.html#gs_quant.timeseries.datetime.value">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">date</span><span class="p">,</span> <span class="n">time</span><span class="p">],</span> <span class="n">method</span><span class="p">:</span> <span class="n">Interpolate</span> <span class="o">=</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">STEP</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Value at specified date or time</span>

<span class="sd">    :param x: timeseries</span>
<span class="sd">    :param date: requested date or time</span>
<span class="sd">    :param method: interpolation method (default: step)</span>
<span class="sd">    :return: value at specified date or time</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns the value of series X at the specified date:</span>

<span class="sd">    :math:`Y_t = X_{date}`</span>

<span class="sd">    If the requested date or time is not present in the series, the value function will return the value from the</span>
<span class="sd">    previous available date or time by default. Caller can specify other interpolation styles via the method param:</span>

<span class="sd">    Interpolation methods:</span>

<span class="sd">    =========   ========================================================================</span>
<span class="sd">    Type        Behavior</span>
<span class="sd">    =========   ========================================================================</span>
<span class="sd">    intersect   Only returns a value for valid dates</span>
<span class="sd">    nan         Value will be NaN for dates not present in the series</span>
<span class="sd">    zero        Value will be zero for dates not present in the series</span>
<span class="sd">    step        Value of the previous valid point if requested date does not exist.</span>
<span class="sd">                Values prior to the first date will be equivalent to the first available</span>
<span class="sd">                value</span>
<span class="sd">    =========   ========================================================================</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Value of series on 5Mar18:</span>

<span class="sd">    &gt;&gt;&gt; a = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; value(a, date(2019, 1, 3)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`interpolate`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">date</span><span class="p">],</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="day"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.day.html#gs_quant.timeseries.datetime.day">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">day</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Day of each value in series</span>

<span class="sd">    :param x: time series</span>
<span class="sd">    :return: day of observations</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns the day as a numeric value for each observation in the series:</span>

<span class="sd">    :math:`Y_t = day(t)`</span>

<span class="sd">    Day of the time or date is the integer day number within the month, e.g. 1-31</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Day for observations in series:</span>

<span class="sd">    &gt;&gt;&gt; series = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; days = day(series)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`month` :func:`year`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">())</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day</span></div>


<div class="viewcode-block" id="month"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.month.html#gs_quant.timeseries.datetime.month">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">month</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Month of each value in series</span>

<span class="sd">    :param x: time series</span>
<span class="sd">    :return: month of observations</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns the month as a numeric value for each observation in the series:</span>

<span class="sd">    :math:`Y_t = month(t)`</span>

<span class="sd">    Month of the time or date is the integer month number, e.g. 1-12</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Day for observations in series:</span>

<span class="sd">    &gt;&gt;&gt; series = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; days = month(series)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`day` :func:`year`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">())</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span></div>


<div class="viewcode-block" id="year"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.year.html#gs_quant.timeseries.datetime.year">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">year</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Year of each value in series</span>

<span class="sd">    :param x: time series</span>
<span class="sd">    :return: year of observations</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns the year as a numeric value for each observation in the series:</span>

<span class="sd">    :math:`Y_t = year(t)`</span>

<span class="sd">    Year of the time or date is the integer year number, e.g. 2019, 2020</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Year for observations in series:</span>

<span class="sd">    &gt;&gt;&gt; series = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; days = year(series)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`day` :func:`month`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">())</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span></div>


<div class="viewcode-block" id="quarter"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.quarter.html#gs_quant.timeseries.datetime.quarter">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">quarter</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quarter of each value in series</span>

<span class="sd">    :param x: time series</span>
<span class="sd">    :return: quarter of observations</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns the quarter as a numeric value for each observation in the series:</span>

<span class="sd">    :math:`Y_t = quarter(t)`</span>

<span class="sd">    Quarter of the time or date is the integer quarter number, e.g. 1, 2, 3, 4</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Quarter for observations in series:</span>

<span class="sd">    &gt;&gt;&gt; series = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; days = quarter(series)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`day` :func:`month`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">())</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">quarter</span></div>


<div class="viewcode-block" id="weekday"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.weekday.html#gs_quant.timeseries.datetime.weekday">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">weekday</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Weekday of each value in series</span>

<span class="sd">    :param x: time series</span>
<span class="sd">    :return: weekday of observations</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns the weekday as a numeric value for each observation in the series:</span>

<span class="sd">    :math:`Y_t = weekday(t)`</span>

<span class="sd">    Weekday of the time or date is the integer day of the week, e.g. 0-6, where 0 represents Monday</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Weekday for observations in series:</span>

<span class="sd">    &gt;&gt;&gt; series = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; days = weekday(series)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`day` :func:`month`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">())</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">weekday</span></div>


<span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">day_count_fractions</span><span class="p">(</span>
    <span class="n">dates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">date</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span>
    <span class="n">convention</span><span class="p">:</span> <span class="n">DayCountConvention</span> <span class="o">=</span> <span class="n">DayCountConvention</span><span class="o">.</span><span class="n">ACTUAL_360</span><span class="p">,</span>
    <span class="n">frequency</span><span class="p">:</span> <span class="n">PaymentFrequency</span> <span class="o">=</span> <span class="n">PaymentFrequency</span><span class="o">.</span><span class="n">MONTHLY</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Day count fractions between dates in series</span>

<span class="sd">    :param dates: time series or array of dates</span>
<span class="sd">    :param convention: day count convention (default: Actual/360 ISDA)</span>
<span class="sd">    :param frequency: payment frequency of instrument (optional)</span>
<span class="sd">    :return: series of day count fractions</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns the day count fraction between dates in the series</span>

<span class="sd">    :math:`Y_t = DCF(t_{-1}, t)`</span>

<span class="sd">    Default is Actual/360 per ISDA specification:</span>

<span class="sd">    :math:`Y_t = \frac{Days(t_{-1}, t)}{360}`</span>

<span class="sd">    For a full list of available conventions, see</span>
<span class="sd">    `Day Count Conventions &lt;https://developer.gs.com/docs/gsquant/guides/Dates/1-day-count-conventions&gt;`_.</span>
<span class="sd">    For more information on day count conventions, see the</span>
<span class="sd">    `day count conventions &lt;https://en.wikipedia.org/wiki/Day_count_convention&gt;`_ page on Wikipedia</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Weekday for observations in series:</span>

<span class="sd">    &gt;&gt;&gt; series = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; days = day_count_fractions(series)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`day` :func:`month` :func:`year`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">date_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dates</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">date_list</span> <span class="o">=</span> <span class="n">dates</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">date_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])</span>

    <span class="n">start_dates</span> <span class="o">=</span> <span class="n">date_list</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">end_dates</span> <span class="o">=</span> <span class="n">date_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">date_list</span><span class="p">)]</span>

    <span class="n">dcfs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">day_count_fraction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">convention</span><span class="p">,</span> <span class="n">frequency</span><span class="p">),</span> <span class="n">start_dates</span><span class="p">,</span> <span class="n">end_dates</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">dcfs</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">date_list</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">date_list</span><span class="p">)])</span>


<div class="viewcode-block" id="date_range"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.date_range.html#gs_quant.timeseries.datetime.date_range">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">date_range</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">date</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">end_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">date</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
               <span class="n">weekdays_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a time series from a (sub-)range of dates in an existing time series.</span>

<span class="sd">    :param x: time series</span>
<span class="sd">    :param start_date: start date for the sliced time series. If integer, number of observations after the first</span>
<span class="sd">    :param end_date: end date for the sliced time series. If integer, number of observations before the last</span>
<span class="sd">    :param weekdays_only: whether to include only weekdays in the sliced ranges</span>
<span class="sd">    :return: sliced time series</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns a restricted (&quot;sliced&quot;) time series based on start and end dates:</span>

<span class="sd">    :math:`Y_t = R_t |_{start &lt; t &lt; end}`</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Slice the first and last week of a time series:</span>

<span class="sd">    &gt;&gt;&gt; series = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; sliced_series = date_range(series,7,7)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`day` :func: `lag`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_all_dates</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">date</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s1">&#39;input is not a time series&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">start_date</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">end_date</span><span class="p">)]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">start_date</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">end_date</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">weekdays_only</span><span class="p">:</span>
        <span class="n">week_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">wd</span> <span class="o">=</span> <span class="n">start_date</span><span class="o">.</span><span class="n">weekday</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">wd</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">start_date</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">7</span> <span class="o">-</span> <span class="n">wd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">week_mask</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">7</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_date_range</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">,</span> <span class="n">week_mask</span><span class="o">=</span><span class="n">week_mask</span><span class="p">)))]</span></div>


<div class="viewcode-block" id="prepend"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.prepend.html#gs_quant.timeseries.datetime.prepend">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepend data series</span>

<span class="sd">    :param x: an array of timeseries</span>
<span class="sd">    :return: concatenated timeseries</span>

<span class="sd">    **Usage**</span>

<span class="sd">    For input series [:math:`x_1`, :math:`x_2`, ... , :math:`X_n`], takes data from series :math:`X_i` until</span>
<span class="sd">    the first date for which :math:`X_{i+1}` has data, useful when a higher quality series has a shorter history</span>
<span class="sd">    than a lower quality series.</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Prepend two series:</span>

<span class="sd">    &gt;&gt;&gt; x = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; y = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; prepend([x, y])</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`union`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="union"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.datetime.union.html#gs_quant.timeseries.datetime.union">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill in missing dates or times of one series with another</span>

<span class="sd">    :param x: an array of timeseries</span>
<span class="sd">    :return: combined series</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Starting from :math:`i=1`, takes points from series :math:`x_i`. Where points are missing from :math:`x_i`,</span>
<span class="sd">    returns points from :math:`x_{i+1}`.</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Union of two series:</span>

<span class="sd">    &gt;&gt;&gt; x = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; y = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; union([x, y])</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`prepend`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">series</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  <hr />
  
</footer>
        </div>
      </div>

    </section>

  </div>
  

  
  
    
   

</body>
</html>