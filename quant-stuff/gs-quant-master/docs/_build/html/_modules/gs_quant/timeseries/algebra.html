

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gs_quant.timeseries.algebra &mdash; gs_quant 0.1 documentation</title>
  

    
  <script crossorigin src="/resources/react/16-8-6/prod/react.production.min.js"></script>
  <script
    crossorigin src="/resources/react/16-8-6/prod/react-dom.production.min.js"></script>

     
    <script src='/resources/mathjax/latest.js?config=TeX-AMS-MML_HTMLorMML' async></script> 
    
    <script type="text/javascript" src="../../../_static/../../../auto-mount.js"></script>
    <link rel="stylesheet" href="../../../_static/../../../auto-mount.css" type="text/css" />

  
  
  
  

  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" /> 
</head>

<!-- Hello from the future. -->
<div id="mq-doc-navbar-inject"></div>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    <a data-toggle="wy-nav-top" id="gs-developer-action-button-container" ontouchstart="">
      <div data-toggle="gs-nav-action" id="gs-nav-action"></div>
    </a>
    
    <nav id="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        
        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Packages</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Data Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datetime.html">Datetime Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../instrument.html">Instrument Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../markets.html">Markets Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../risk.html">Risk Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../timeseries.html">Timeseries Package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Packages</a> /</li>
        
          <li><a href="../../index.html">Module code</a> /</li>
        
      <li>gs_quant.timeseries.algebra</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gs_quant.timeseries.algebra</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 Goldman Sachs.</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1"># Unless required by applicable law or agreed to in writing,</span>
<span class="c1"># software distributed under the License is distributed on an</span>
<span class="c1"># &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span>
<span class="c1"># KIND, either express or implied.  See the License for the</span>
<span class="c1"># specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Chart Service will attempt to make public functions (not prefixed with _) from this module available. Such functions</span>
<span class="c1"># should be fully documented: docstrings should describe parameters and the return value, and provide a 1-line</span>
<span class="c1"># description. Type annotations should be provided for parameters.</span>


<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">.datetime</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.helper</span> <span class="kn">import</span> <span class="n">plot_function</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">gs_quant.errors</span> <span class="kn">import</span> <span class="n">MqTypeError</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Algebra library contains basic numerical and algebraic operations, including addition, division, multiplication,</span>
<span class="sd">division and other functions on timeseries</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">FilterOperator</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">LESS</span> <span class="o">=</span> <span class="s1">&#39;less_than&#39;</span>
    <span class="n">GREATER</span> <span class="o">=</span> <span class="s1">&#39;greater_than&#39;</span>
    <span class="n">L_EQUALS</span> <span class="o">=</span> <span class="s1">&#39;l_equals&#39;</span>
    <span class="n">G_EQUALS</span> <span class="o">=</span> <span class="s1">&#39;g_equals&#39;</span>
    <span class="n">EQUALS</span> <span class="o">=</span> <span class="s1">&#39;equals&#39;</span>
    <span class="n">N_EQUALS</span> <span class="o">=</span> <span class="s1">&#39;not_equals&#39;</span>


<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.add.html#gs_quant.timeseries.algebra.add">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">method</span><span class="p">:</span> <span class="n">Interpolate</span> <span class="o">=</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">STEP</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add two series or scalars</span>

<span class="sd">    :param x: timeseries or scalar</span>
<span class="sd">    :param y: timeseries or scalar</span>
<span class="sd">    :param method: interpolation method (default: step). Only used when both x and y are timeseries</span>
<span class="sd">    :return: timeseries of x + y or sum of the given real numbers</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Add two series or scalar variables with the given interpolation method</span>

<span class="sd">    :math:`R_t =  X_t + Y_t`</span>

<span class="sd">    Alignment operators:</span>

<span class="sd">    =========   ========================================================================</span>
<span class="sd">    Method      Behavior</span>
<span class="sd">    =========   ========================================================================</span>
<span class="sd">    intersect   Resultant series only has values on the intersection of dates. Values</span>
<span class="sd">                for dates present in only one series will be ignored</span>
<span class="sd">    nan         Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as nan in the</span>
<span class="sd">                other series, and therefore in the resultant series</span>
<span class="sd">    zero        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as zero in the</span>
<span class="sd">                other series</span>
<span class="sd">    step        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be interpolated via step</span>
<span class="sd">                function in the other series</span>
<span class="sd">    time        Resultant series have values on the union of dates / times. Missing</span>
<span class="sd">                values surrounded by valid values will be interpolated given length of</span>
<span class="sd">                interval. Input series must use DateTimeIndex.</span>
<span class="sd">    =========   ========================================================================</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Add two series:</span>

<span class="sd">    &gt;&gt;&gt; a = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; b = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; add(a, b, Interpolate.STEP)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`subtract`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

    <span class="p">[</span><span class="n">x_align</span><span class="p">,</span> <span class="n">y_align</span><span class="p">]</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_align</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">y_align</span><span class="p">)</span></div>


<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.subtract.html#gs_quant.timeseries.algebra.subtract">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">method</span><span class="p">:</span> <span class="n">Interpolate</span> <span class="o">=</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">STEP</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add two series or scalars</span>

<span class="sd">    :param x: timeseries or scalar</span>
<span class="sd">    :param y: timeseries or scalar</span>
<span class="sd">    :param method: index alignment operator (default: intersect). Only used when both x and y are timeseries</span>
<span class="sd">    :return: timeseries of x - y or difference between the given real numbers</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Subtracts one series or scalar from another applying the given interpolation method</span>

<span class="sd">    :math:`R_t =  X_t - Y_t`</span>

<span class="sd">    Alignment operators:</span>

<span class="sd">    =========   ========================================================================</span>
<span class="sd">    Method      Behavior</span>
<span class="sd">    =========   ========================================================================</span>
<span class="sd">    intersect   Resultant series only has values on the intersection of dates.</span>
<span class="sd">                Values for dates present in only one series will be ignored</span>
<span class="sd">    nan         Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as nan in the</span>
<span class="sd">                other series, and therefore in the resultant series</span>
<span class="sd">    zero        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as zero in the</span>
<span class="sd">                other series</span>
<span class="sd">    step        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be interpolated via step</span>
<span class="sd">                function in the other series</span>
<span class="sd">    time        Resultant series have values on the union of dates / times. Missing</span>
<span class="sd">                values surrounded by valid values will be interpolated given length of</span>
<span class="sd">                interval. Input series must use DateTimeIndex.</span>
<span class="sd">    =========   ========================================================================</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Subtract one series from another:</span>

<span class="sd">    &gt;&gt;&gt; a = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; b = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; subtract(a, b, Interpolate.STEP)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`add`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Determine how we want to handle observations prior to start date</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

    <span class="p">[</span><span class="n">x_align</span><span class="p">,</span> <span class="n">y_align</span><span class="p">]</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_align</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">y_align</span><span class="p">)</span></div>


<div class="viewcode-block" id="multiply"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.multiply.html#gs_quant.timeseries.algebra.multiply">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">method</span><span class="p">:</span> <span class="n">Interpolate</span> <span class="o">=</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">STEP</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiply two series or scalars</span>

<span class="sd">    :param x: timeseries or scalar</span>
<span class="sd">    :param y: timeseries or scalar</span>
<span class="sd">    :param method: interpolation method (default: step). Only used when both x and y are timeseries</span>
<span class="sd">    :return: timeseries of x * y or product of the given real numbers</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Multiply two series or scalar variables applying the given interpolation method</span>

<span class="sd">    :math:`R_t =  X_t \\times Y_t`</span>

<span class="sd">    Alignment operators:</span>

<span class="sd">    =========   ========================================================================</span>
<span class="sd">    Method      Behavior</span>
<span class="sd">    =========   ========================================================================</span>
<span class="sd">    intersect   Resultant series only has values on the intersection of dates. Values</span>
<span class="sd">                for dates present in only one series will be ignored</span>
<span class="sd">    nan         Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as nan in the</span>
<span class="sd">                other series, and therefore in the resultant series</span>
<span class="sd">    zero        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as zero in the</span>
<span class="sd">                other series</span>
<span class="sd">    step        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be interpolated via step</span>
<span class="sd">                function in the other series</span>
<span class="sd">    time        Resultant series have values on the union of dates / times. Missing</span>
<span class="sd">                values surrounded by valid values will be interpolated given length of</span>
<span class="sd">                interval. Input series must use DateTimeIndex.</span>
<span class="sd">    =========   ========================================================================</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Multiply two series:</span>

<span class="sd">    &gt;&gt;&gt; a = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; b = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; multiply(a, b, Interpolate.STEP)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`divide`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

    <span class="p">[</span><span class="n">x_align</span><span class="p">,</span> <span class="n">y_align</span><span class="p">]</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_align</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">y_align</span><span class="p">)</span></div>


<div class="viewcode-block" id="divide"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.divide.html#gs_quant.timeseries.algebra.divide">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">method</span><span class="p">:</span> <span class="n">Interpolate</span> <span class="o">=</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">STEP</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divide two series or scalars</span>

<span class="sd">    :param x: timeseries or scalar</span>
<span class="sd">    :param y: timeseries or scalar</span>
<span class="sd">    :param method: interpolation method (default: step). Only used when both x and y are timeseries</span>
<span class="sd">    :return: timeseries of x / y or quotient of the given real numbers</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Divide two series or scalar variables applying the given interpolation method</span>

<span class="sd">    :math:`R_t =  X_t / Y_t`</span>

<span class="sd">    Alignment operators:</span>

<span class="sd">    =========   ========================================================================</span>
<span class="sd">    Method      Behavior</span>
<span class="sd">    =========   ========================================================================</span>
<span class="sd">    intersect   Resultant series only has values on the intersection of dates.</span>
<span class="sd">                Values for dates present in only one series will be ignored</span>
<span class="sd">    nan         Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as nan in the</span>
<span class="sd">                other series, and therefore in the resultant series</span>
<span class="sd">    zero        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as zero in the</span>
<span class="sd">                other series</span>
<span class="sd">    step        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be interpolated via step</span>
<span class="sd">                function in the other series</span>
<span class="sd">    time        Resultant series have values on the union of dates / times. Missing</span>
<span class="sd">                values surrounded by valid values will be interpolated given length of</span>
<span class="sd">                interval. Input series must use DateTimeIndex.</span>
<span class="sd">    =========   ========================================================================</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Divide two series:</span>

<span class="sd">    &gt;&gt;&gt; a = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; b = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; divide(a, b, Interpolate.STEP)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`multiply`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>

    <span class="p">[</span><span class="n">x_align</span><span class="p">,</span> <span class="n">y_align</span><span class="p">]</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_align</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">y_align</span><span class="p">)</span></div>


<div class="viewcode-block" id="floordiv"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.floordiv.html#gs_quant.timeseries.algebra.floordiv">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">floordiv</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">],</span> <span class="n">method</span><span class="p">:</span> <span class="n">Interpolate</span> <span class="o">=</span> <span class="n">Interpolate</span><span class="o">.</span><span class="n">STEP</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Real</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Floor divide two series or scalars</span>

<span class="sd">    :param x: timeseries or scalar</span>
<span class="sd">    :param y: timeseries or scalar</span>
<span class="sd">    :param method: interpolation method (default: step). Only used for operating two series</span>
<span class="sd">    :return: timeseries of x // y or quotient of the floor division of the given real numbers</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Divide two series or scalar variables applying the given interpolation method</span>

<span class="sd">    :math:`R_t =  X_t / Y_t`</span>

<span class="sd">    Alignment operators:</span>

<span class="sd">    =========   ========================================================================</span>
<span class="sd">    Method      Behavior</span>
<span class="sd">    =========   ========================================================================</span>
<span class="sd">    intersect   Resultant series only has values on the intersection of dates.</span>
<span class="sd">                Values for dates present in only one series will be ignored</span>
<span class="sd">    nan         Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as nan in the</span>
<span class="sd">                other series, and therefore in the resultant series</span>
<span class="sd">    zero        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be treated as zero in the</span>
<span class="sd">                other series</span>
<span class="sd">    step        Resultant series has values on the union of dates in both series. Values</span>
<span class="sd">                for dates only available in one series will be interpolated via step</span>
<span class="sd">                function in the other series</span>
<span class="sd">    =========   ========================================================================</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Floor divide two series:</span>

<span class="sd">    &gt;&gt;&gt; a = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; b = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; floordiv(a, b, Interpolate.STEP)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`divide`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">//</span> <span class="n">y</span>

    <span class="p">[</span><span class="n">x_align</span><span class="p">,</span> <span class="n">y_align</span><span class="p">]</span> <span class="o">=</span> <span class="n">align</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x_align</span><span class="o">.</span><span class="n">floordiv</span><span class="p">(</span><span class="n">y_align</span><span class="p">)</span></div>


<div class="viewcode-block" id="exp"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.exp.html#gs_quant.timeseries.algebra.exp">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exponential of series</span>

<span class="sd">    :param x: timeseries</span>
<span class="sd">    :return: exponential of each element</span>

<span class="sd">    **Usage**</span>

<span class="sd">    For each element in the series, :math:`X_t`, raise :math:`e` (Euler&#39;s number) to the power of :math:`X_t`.</span>
<span class="sd">    Euler&#39;s number is the base of the natural logarithm, :math:`ln`.</span>

<span class="sd">    :math:`R_t = e^{X_t}`</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Raise :math:`e` to the power :math:`1`. Returns Euler&#39;s number, approximately 2.71828</span>

<span class="sd">    &gt;&gt;&gt; exp(1)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`log`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.log.html#gs_quant.timeseries.algebra.log">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Natural logarithm of series</span>

<span class="sd">    :param x: timeseries</span>
<span class="sd">    :return: series with exponential of each element</span>

<span class="sd">    **Usage**</span>

<span class="sd">    For each element in the series, :math:`X_t`, return the natural logarithm :math:`ln` of :math:`X_t`</span>
<span class="sd">    The natural logarithm is the logarithm in base :math:`e`.</span>

<span class="sd">    :math:`R_t = log(X_t)`</span>

<span class="sd">    This function is the inverse of the exponential function.</span>

<span class="sd">    More information on `logarithms &lt;https://en.wikipedia.org/wiki/Logarithm&gt;`_</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Take natural logarithm of 3</span>

<span class="sd">    &gt;&gt;&gt; log(3)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`exp`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="power"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.power.html#gs_quant.timeseries.algebra.power">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raise each element in series to power</span>

<span class="sd">    :param x: timeseries</span>
<span class="sd">    :param y: value</span>
<span class="sd">    :return: date-based time series of square roots</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Raise each value in time series :math:`X_t` to the power :math:`y`:</span>

<span class="sd">    :math:`R_t = X_t^{y}`</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Generate price series and raise each value to the power 2:</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; power(prices, 2)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`sqrt`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="sqrt"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.sqrt.html#gs_quant.timeseries.algebra.sqrt">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Real</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Real</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Square root of (a) each element in a series or (b) a real number</span>

<span class="sd">    :param x: date-based time series of prices or real number</span>
<span class="sd">    :return: date-based time series of square roots or square root of given number</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Return the square root of each value in time series :math:`X_t`:</span>

<span class="sd">    :math:`R_t = \\sqrt{X_t}`</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Generate price series and take square root of each value:</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; sqrt(prices)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`pow`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># return int if result is integral (should work for values up to 2**53)</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="n">result</span> <span class="k">else</span> <span class="n">result</span></div>


<div class="viewcode-block" id="abs_"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.abs_.html#gs_quant.timeseries.algebra.abs_">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">abs_</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Absolute value of each element in series</span>

<span class="sd">    :param x: date-based time series of prices</span>
<span class="sd">    :return: date-based time series of absolute value</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Return the absolute value of :math:`X`. For each value in time series :math:`X_t`, return :math:`X_t` if :math:`X_t`</span>
<span class="sd">    is greater than or equal to 0; otherwise return :math:`-X_t`:</span>

<span class="sd">    :math:`R_t = |X_t|`</span>

<span class="sd">    Equivalent to :math:`R_t = \sqrt{X_t^2}`</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Generate price series and take absolute value of :math:`X_t-100`</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100) - 100</span>
<span class="sd">    &gt;&gt;&gt; abs_(prices)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`exp` :func:`sqrt`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="floor"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.floor.html#gs_quant.timeseries.algebra.floor">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Floor series at minimum value</span>

<span class="sd">    :param x: date-based time series of prices</span>
<span class="sd">    :param value: minimum value</span>
<span class="sd">    :return: date-based time series of maximum value</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns series where all values are greater than or equal to the minimum value.</span>

<span class="sd">    :math:`R_t = max(X_t, value)`</span>

<span class="sd">    See `Floor and Ceil functions &lt;https://en.wikipedia.org/wiki/Floor_and_ceiling_functions&gt;`_ for more details</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Generate price series and floor all values at 100</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; floor(prices, 100)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`ceil`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span></div>


<div class="viewcode-block" id="ceil"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.ceil.html#gs_quant.timeseries.algebra.ceil">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cap series at maximum value</span>

<span class="sd">    :param x: date-based time series of prices</span>
<span class="sd">    :param value: maximum value</span>
<span class="sd">    :return: date-based time series of maximum value</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns series where all values are less than or equal to the maximum value.</span>

<span class="sd">    :math:`R_t = min(X_t, value)`</span>

<span class="sd">    See `Floor and Ceil functions &lt;https://en.wikipedia.org/wiki/Floor_and_ceiling_functions&gt;`_ for more details</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Generate price series and floor all values at 100</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; floor(prices, 100)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`floor`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span></div>


<div class="viewcode-block" id="filter_"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.filter_.html#gs_quant.timeseries.algebra.filter_">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">filter_</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FilterOperator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes values where comparison with the operator and value combination results in true, defaults to removing</span>
<span class="sd">    missing values from the series</span>

<span class="sd">    :param x: timeseries</span>
<span class="sd">    :param operator: FilterOperator describing logic for value removal, e.g &#39;less_than&#39;</span>
<span class="sd">    :param value: number indicating value(s) to remove from the series</span>
<span class="sd">    :return: timeseries with specified values removed</span>


<span class="sd">    **Usage**</span>

<span class="sd">    Remove each value determined by operator and value from timeseries where that expression yields true</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Remove 0 from time series</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; filter_(prices, FilterOperator.EQUALS, 0)</span>

<span class="sd">    Remove positive numbers from time series</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; filter_(prices, FilterOperator.GREATER, 0)</span>

<span class="sd">    Remove missing values from time series</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; filter_(prices)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">operator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s1">&#39;No value is specified for the operator&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="n">FilterOperator</span><span class="o">.</span><span class="n">EQUALS</span><span class="p">:</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="n">FilterOperator</span><span class="o">.</span><span class="n">GREATER</span><span class="p">:</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="n">FilterOperator</span><span class="o">.</span><span class="n">LESS</span><span class="p">:</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="n">FilterOperator</span><span class="o">.</span><span class="n">L_EQUALS</span><span class="p">:</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="n">FilterOperator</span><span class="o">.</span><span class="n">G_EQUALS</span><span class="p">:</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="n">FilterOperator</span><span class="o">.</span><span class="n">N_EQUALS</span><span class="p">:</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">operator</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected operator: &#39;</span> <span class="o">+</span> <span class="n">operator</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">remove</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="smooth_spikes"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.smooth_spikes.html#gs_quant.timeseries.algebra.smooth_spikes">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">smooth_spikes</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth out the spikes of a series. If a point is larger/smaller than (1 +/- threshold) times both neighbors, replace</span>
<span class="sd">    it with the average of those neighbours. Note: the first and last points in the input series are dropped.</span>

<span class="sd">    :param x: timeseries</span>
<span class="sd">    :param threshold: minimum increment to trigger filter</span>
<span class="sd">    :return: smoothed timeseries</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Returns series where values that exceed the threshold relative to both neighbors are replaced.</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Generate price series and smooth spikes over a threshold of 0.5.</span>

<span class="sd">    &gt;&gt;&gt; prices = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; smooth_spikes(prices, 0.5)</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`exponential_moving_average`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">multiplier</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">current</span><span class="p">,</span> <span class="n">next_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">next_</span>
        <span class="n">next_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">scaled</span> <span class="o">=</span> <span class="n">current</span> <span class="o">*</span> <span class="n">multiplier</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">&gt;</span> <span class="n">previous</span> <span class="o">*</span> <span class="n">multiplier</span> <span class="ow">and</span> <span class="n">current</span> <span class="o">&gt;</span> <span class="n">next_</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">previous</span> <span class="o">&gt;</span> <span class="n">scaled</span> <span class="ow">and</span> <span class="n">next_</span> <span class="o">&gt;</span> <span class="n">scaled</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">previous</span> <span class="o">+</span> <span class="n">next_</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="repeat"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.repeat.html#gs_quant.timeseries.algebra.repeat">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Repeats values for days where data is missing. For any date with missing data, the last recorded value is used.</span>
<span class="sd">    Optionally downsamples the result such that there are data points every n days.</span>

<span class="sd">    :param x: date-based timeseries</span>
<span class="sd">    :param n: desired frequency of output</span>
<span class="sd">    :return: a timeseries that has been forward-filled, and optionally downsampled</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Fill missing values with last seen value e.g. to combine daily with weekly or monthly data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">367</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s1">&#39;n must be between 0 and 367&#39;</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">D&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_sum_boolean_series</span><span class="p">(</span><span class="o">*</span><span class="n">series</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s1">&#39;expected between 2 and 100 arguments&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">series</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MqTypeError</span><span class="p">(</span><span class="s1">&#39;all arguments must be series&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot perform operation on series with value(s) other than 1 and 0: </span><span class="si">{</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">current</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">series</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">current</span>


<div class="viewcode-block" id="and_"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.and_.html#gs_quant.timeseries.algebra.and_">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">and_</span><span class="p">(</span><span class="o">*</span><span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logical &quot;and&quot; of two or more boolean series.</span>

<span class="sd">    :param series: input series</span>
<span class="sd">    :return: result series (of numeric type, with booleans represented as 1s and 0s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_sum_boolean_series</span><span class="p">(</span><span class="o">*</span><span class="n">series</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="or_"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.or_.html#gs_quant.timeseries.algebra.or_">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">or_</span><span class="p">(</span><span class="o">*</span><span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logical &quot;or&quot; of two or more boolean series.</span>

<span class="sd">    :param series: input series</span>
<span class="sd">    :return: result series (of numeric type, with booleans represented as 1s and 0s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_sum_boolean_series</span><span class="p">(</span><span class="o">*</span><span class="n">series</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="not_"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.not_.html#gs_quant.timeseries.algebra.not_">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">not_</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logical negation of a single boolean series.</span>

<span class="sd">    :param series: single input series</span>
<span class="sd">    :return: result series (of numeric type, with booleans represented as 1s and 0s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">series</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot negate series with value(s) other than 1 and 0: </span><span class="si">{</span><span class="n">series</span><span class="o">.</span><span class="n">values</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">series</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="if_"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.if_.html#gs_quant.timeseries.algebra.if_">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">if_</span><span class="p">(</span><span class="n">flags</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a series s. For i in the index of flags, s[i] = x[i] if flags[i] == 1 else y[i].</span>

<span class="sd">    :param flags: series of 1s and 0s</span>
<span class="sd">    :param x: values to use when flag is 1</span>
<span class="sd">    :param y: values to use when flag is 0</span>
<span class="sd">    :return: result series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">flags</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot perform &quot;if&quot; on series with value(s) other than 1 and 0: </span><span class="si">{</span><span class="n">flags</span><span class="o">.</span><span class="n">values</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ensure_series</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">flags</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">flags</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">flags</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MqTypeError</span><span class="p">(</span><span class="s1">&#39;expected a number or series&#39;</span><span class="p">)</span>

    <span class="n">x_flags</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ensure_series</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y_flags</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ensure_series</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">x_flags</span> <span class="o">==</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">y_flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span></div>


<div class="viewcode-block" id="weighted_sum"><a class="viewcode-back" href="../../../functions/gs_quant.timeseries.algebra.weighted_sum.html#gs_quant.timeseries.algebra.weighted_sum">[docs]</a><span class="nd">@plot_function</span>
<span class="k">def</span> <span class="nf">weighted_sum</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a weighted sum.</span>

<span class="sd">    :param series: list of time series</span>
<span class="sd">    :param weights: list of weights</span>
<span class="sd">    :return: time series of weighted average</span>

<span class="sd">    **Usage**</span>

<span class="sd">    Calculate a weighted sum e.g. for a basket.</span>

<span class="sd">    **Examples**</span>

<span class="sd">    Generate price series and get a sum (weights 70%/30%).</span>

<span class="sd">    &gt;&gt;&gt; prices1 = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; prices2 = generate_series(100)</span>
<span class="sd">    &gt;&gt;&gt; mybasket = weighted_sum([prices1, prices2], [0.7, 0.3])</span>

<span class="sd">    **See also**</span>

<span class="sd">    :func:`basket`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">series</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MqTypeError</span><span class="p">(</span><span class="s2">&quot;expected a list of time series&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MqTypeError</span><span class="p">(</span><span class="s2">&quot;expected a list of number for weights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MqValueError</span><span class="p">(</span><span class="s2">&quot;must have one weight for each time series&quot;</span><span class="p">)</span>

    <span class="c1"># for input series, get the intersection of their calendars</span>
    <span class="n">cal</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span>
        <span class="n">reduce</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">curve</span><span class="o">.</span><span class="n">index</span>
                <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">series</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># reindex inputs and calculate</span>
    <span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">cal</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">cal</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  <hr />
  
</footer>
        </div>
      </div>

    </section>

  </div>
  

  
  
    
   

</body>
</html>